

## 순열

서로 다른 것들 중 몇 개를 뽑아 한 줄로 나열하는 것

BJ15649, BJ15654

### 재귀호출을 통한 순열 생성

{1,2,3}을 포함하는 모든 순열을 생성하는 함수

```
numbers[] // 순열 저장
isSelected[] // 인덱스에 해당숫자가 사용중인지 저장
perm(cnt) // cnt: 현재까지 뽑은 수의 개수
	if cnt == 3:
		순열 생성 완료
	else:
		for i from 1 to 3
			if isSelected[i] == true 
				then continue
			numbers[cnt] <- i
			isSelected[i] <- true
			perm(cnt+1)
			isSelected[i] <- false
		end for
```



**DFS**로 구현한다. 결과값은 numbers에 순서대로 값을 하나씩 추가한다.

재귀함수이므로, 종료 조건을 설정해야한다. 이 문제에선 숫자를 cnt개 선택한 상태에서 함수를 실행한다. 지금까지 선택한 숫자의 개수가 목표 개수(3)와 같을 경우, numbers에 있는 숫자를 출력해준다.



perm(cnt) 을 시작하면, 숫자 중 1개를 선택(i)하면서 시작한다.

각 숫자를 이미 선택했는지 확인하기 위해 isSelected라는 배열을 생성했다. 만약 **방금** 선택한 숫자(i)가 이미 선택한 숫자중에 있다면(isSelected[i]==true) continue를 통해 다음 루프를 돈다.

i가 선택한 적 없는 숫자라면, 방금 선택한 숫자(i)를 numbers의 **현재 위치(cnt)**에 추가한다.  숫자를 선택했으니 isSelected 내의 해당 숫자(i)를 true로 변경해준다.

여기부터 중요한데, DFS를 통해 깊게 들어갔다가 탐색을 마친 후, 거꾸로 돌아오는 코드를 작성할 것이기때문에 돌아올때는 방금 값을 true로 변경한 숫자(i)의 선택여부를 false로 바꾸면서 다음 루프를 돌아야한다. 

숫자를 cnt개 선택한 후, 다음 숫자를 탐색하기 위해 perm(cnt+1)을 실행한다. 탐색을 마친 후 방금 선택한 숫자(i)의 선택여부를 false로 바꿔준다. 탐색하다가 cnt==3인 경우엔 출력도 했을 것이다.

코드가 직관적이진 않을수도 있으니 로직 자체를 외워버리고 익숙해지는 것도 방법이다.



## 조합

서로 다른 n개의 원소중 r개를 순서없이 골라낸 것

nCr = (n-c)C(r-1) + (n-1)Cr

BJ 15650, BJ15655

### 재귀호출을 통한 순열 생성



```
input[] : n개의 원소를 갖고있는 배열
numbers[] : r개의 크기의 배열, 조합이 저장될 배열
comb(cnt, start) // cnt:현재까지 뽑은 조합원소 개수, start: 조합 시도할 원소의 시작인덱스
	if cnt==r
		조합 생성 완료
	else
		for i from start to n-1
			numbers[cnt] <- input[i]
			comb(cnt+1, i+1)
		end for
end comb()
```

DFS로 구현하는 것은 순열과 마찬가지다. 다만, 조합은 순서를 고려하기때문에 순열의 결과 중 순서에 맞는 결과만 선택한다. 그 방법은 **탐색의 범위를 이전 숫자보다 큰 숫자들로 제한**하는 것이다.

더 깊은 탐색 단계로 들어갈때마다, 현재 내가 결과에 저장한 숫자의 개수와 숫자의 값을 넘겨준다. 위의 코드에선 숫자의 값이 i고, 만약 숫자가 1~n이 아닌 임의의 숫자들이라면 해당 숫자의 index를 넘겨준다.

더 깊은 탐색에서는 탐색의 범위가 이전에 넣은 숫자(i)보다 더 큰 숫자(i+1)부터 탐색하기 위해 parameter start에 i+1을 넘겨준다. 