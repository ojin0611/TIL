[TOC]



# 순차 리스트

순차 리스트는 배열의 인덱스를 이용해 원하는 위치의 데이터에 접근할 수 있다.



순차리스트는 중간에 삽입, 삭제 연산을 할 때 해당 위치 다음의 항목들을 이동해야한다. 때문에 삽입/삭제 연산이 빈번하게 일어날수록 작업에 소요되는 시간이 크게 증가한다.

배열의 크기가 정해져있어서 메모리가 남거나 부족한 경우가 발생한다.



# 연결 리스트

자료를 임의의 저장공간에 기억시키되, 자료의 순서에 따라 노드의 포인터 부분을 이용해 서로 연결시킨 구조다. 삽입,삭제가 용이하고 기억공간이 연속적이지 않아도 저장이 가능하다.

앞에서 사용하던 큐(Queue)도 인터페이스 형태로, 연결 리스트(LinkedList)를 통해 생성한다. 그렇기때문에 사이즈가 가변적이고 쉽게 늘어난다.

링크드리스트는 순차 리스트에 비해 기억공간 이용 효율이 좋지 않다. 포인터(링크) 부분이 필요하기때문이다. 즉, 포인터를 찾는 시간때문에 접근 속도가 느리다.



## 기본 구조

### 노드

- 데이터 필드 : 원소의 값을 저장하는 자료구조.
- 링크 필드 : 다음 노드의 주소를 저장하는 자료구조.



### 헤드

리스트의 처음 노드를 가리키는 레퍼런스. 데이터 필드가 없다!



## 단순 연결 리스트

노드가 하나의 링크필드에 의해 다음 노드와 연결되는 구조.

헤드가 가장 앞의 노드를 가리킨다. 최종적으로 NULL을 가리키는 노드가 리스트의 가장 마지막 노드.



**연산**

### 공백 리스트에 노드 삽입

1. 메모리 할당하여 새로운 노드 new 생성. 주소 0x1000 (데이터 필드, 링크 필드 비어있음)
2. 새로운 노드 new의 데이터 필드에 값('A') 저장

3. Head에 저장된 주소값(Null)을 새로운 노드 new의 링크 필드값에 저장 (Null)
4. Head에 새로운 노드 new의 주소값(0x1000) 저장



### 첫번째 노드로 삽입

1. 메모리 할당하여 새로운 노드 new 생성. 주소 0x1008

2. 새로운 노드 new의 데이터 필드에 값('C') 저장
3. Head에 저장된 주소값(0x1000)을 새로운 노드 new의 링크 필드 값에 저장
4. Head에 새로운 노드 new의 주소값(0x1008) 저장



### 마지막 노드로 삽입

1. 메모리 할당하여 새로운 노드 new 생성. 주소 0x1010
2. 새로운 노드 new의 데이터 필드에 값('D') 저장. 링크 필드에는 Null 저장
3. 리스트의 마지막 노드의 링크필드에 새로운 노드 new의 주소값(0x1010) 저장



### 가운데 노드로 삽입

1. 메모리 할당하여 새로운 노드 new 생성. 주소 0x1018

2. 새로운 노드 new의 데이터필드에 값('B') 저장

3. 삽입될 위치의 바로 **다음에 위치한 노드**의 주소(0x1000)를 new의 링크 필드에 저장

   ![image-20210210231036399](images/image-20210210231036399.png)

4. 새로운 노드 new의 주소(0x1018)를 **앞 노드**의 링크 필드에 저장 

   ![image-20210210231052858](images/image-20210210231052858.png)



### 삭제 연산

1. 삭제할 노드의 앞 노드(선행노드) **탐색**
2. 삭제할 노드의 링크 필드를 선행노드의 링크 필드에 복사
3. 삭제할 노드의 링크 필드에 Null 저장 (완전한 삭제. 할당된 메모리 반납)



## 이중 연결 리스트

Doubly Linked List. 양쪽 방향으로 순회할 수 있도록 노드를 연결한 리스트. 두 개의 링크 필드와 한 개의 데이터 필드로 구성.

![image-20210211000903550](images/image-20210211000903550.png)



### 삽입 연산

[시작](#이중-연결-리스트)

1. 메모리 할당하여 새로운 노드 new 생성하고, 데이터 필드에 'D'를 저장한다.

2. 삽입하고자하는 위치의 이전 노드(0x1000)의 next(0x100C)를 new의 next에 저장한다.

   ![image-20210211095150812](images/image-20210211095150812.png)

3. 이전 노드(0x1000)의 주소값을 new의 prev에 저장한다.

   ![image-20210211095210366](images/image-20210211095210366.png)

4. new의 주소를 이전 노드(0x1000)의 next에 저장한다. 

   ![image-20210211095335964](images/image-20210211095335964.png)

5. new의 주소를 new의 오른쪽 노드의 prev에 저장한다.

   ![image-20210211095408640](images/image-20210211095408640.png)



### 삭제 연산

[시작](#이중-연결-리스트)

1. 삭제할 노드의 다음 노드의 주소(0x1018)를 삭제할 노드의 이전 노드의 next에 저장한다.

   ![image-20210214135947620](images/image-20210214135947620.png) 

2. 삭제할 노드의 이전 노드의 주소(0x1000)를 다음 노드의 prev에 저장한다.

   ![image-20210214140138958](images/image-20210214140138958.png) 

3. 삭제할 노드가 가리키는 노드의 prev, next에 Null을 저장한다.

   ![image-20210214140401484](images/image-20210214140401484.png) 