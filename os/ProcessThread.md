[toc]

# 프로세스

## 주소 공간

프로그램이 CPU에 의해 실행되면 프로세스가 생성되고, 메모리에 프로세스 주소 공간이 할당된다.

code : 소스 코드 자체를 구성하는 메모리 영역

data : 전역변수, 정적변수, 배열 (초기화된 데이터)

heap : 동적 할당 시 사용 (`new()`, `malloc()` 등)

stack : 지역변수, 매개변수, 리턴 값 (임시 메모리 영역)



## Context

프로세스의 문맥(context)은 프로세스에 대한 정보로, 하드웨어 문맥(Program Counter, register), 프로세스의 주소공간(code,data,stack), 프로세스 관련 커널 자료 구조(PCB, kernel stack)를 포함하고 있다.

PCB는 프로세스를 관리할 필요가 있는 정보를 포함하는 운영체제 커널의 자료구조다. 운영체제가 프로세스를 관리하기 위해 유지하는 프로세스의 정보다. 프로세스 생성 시 PCB가 생성되고, 프로세스가 완료되면 제거된다.



## 상태

프로세스는 상태가 변경되며 수행된다.

![image-20210602140336494](images/image-20210602140336494.png) 

New : 생성중

Ready : CPU를 기다리는 상태. 메모리에 프로세스를 올려놓고 CPU가 instruction을 바로 실행할 수 있게 대기중.

Running : CPU를 잡고 instruction을 수행중인 상태.

> Running에서 빠져나오는 방법은 3가지다. I/O, Timer, Exit

Blocked(=wait, sleep) : I/O같은 오래 걸리는 작업을 하고 있어 CPU를 얻어도 소용없는 상태다. 프로세스가 요청한 이벤트가 즉시 만족되지않아 이를 기다리는 상태다.

Suspended(=stopped) : 외부적인 이유로 프로세스 수행이 정지된 상태. 디스크에 swap out된다. blocked는 event를 만족하면 ready가 되지만 suspended는 외부에서 resume해줘야 active된다. 

Terminated : 수행이 끝난 상태

![image-20210602183007135](images/image-20210602183007135.png) 



## Context Switching

프로세스의 상태 정보를 저장하고 복원하는 일련의 과정.

즉, 동작 중인 프로세스가 대기하면서 해당 프로세스의 상태를 PCB에 보관하고, 대기하고 있던 다음 순번의 프로세스가 동작하면서 이전에 PCB에 보관했던 프로세스 상태를 복구하는 과정을 말한다.

> 프로세스는 각 독립된 메모리 영역을 할당받아 사용되므로, 캐시 메모리 초기화와 같은 무거운 작업이 진행되었을 때 오버헤드가 발생할 문제가 존재한다.



"프로세스 A -> 시스템콜 -> 프로세스 A" 의 경우, PCB에 프로세스 문맥을 저장하지만 context switching은 발생하지 않는다. "프로세스 A -> kernel mode -> 프로세스 B"의 경우는 문맥 교환이 발생해 오버헤드가 커진다. (cache memory flush 등)



# 프로세스 스케줄링

프로세스는 프로세스 큐들을 왔다갔다하면서 (놀이동산에서 놀이기구 줄 서듯이) 줄을 선다. 이 큐들은 커널의 data 영역에 존재하고, 프로세스 상태에 따라 CPU를 주거나 주지 않는다. 큐의 종류는 Ready Queue, Device Queues, Resource Queue 등이 있다. 

위의 큐에 존재하는 프로세스들의 작업 순서를 정해주는 일(스케줄링)이 필요한데 이 작업을 스케줄러가 해준다.

## 스케줄러

**Short-term scheduler** : CPU scheduler. 어떤 프로세스를 다음번에 running시킬지 결정한다. 

**Long-term scheduler** : Job Scheduler. New 상태의 프로세스를 ready queue로 보낼지 결정한다. (admit) 프로세스에 메모리를 주는 문제를 해결하고, 메모리에 프로그램을 몇 개 올릴 지 제어하는 역할을 한다. 근데 요즘(보통, time-sharing system)은 무조건 ready 상태로 보낸다. 

**Medium-term scheduler** : swapper라고도 불리며, 여유 공간 마련을 위해 프로세스를 통째로 메모리에서 디스크로 쫓아낸다. 



# 쓰레드

동일한 일을 하는 프로세스가 여러 개 있으면 메모리 낭비가 발생한다. 이 때 하나의 메모리를 띄우고, 프로세스마다 다른 부분의 코드를 실행하면 효율적인데 이 개념을 도입한게 thread다. 

프로세스의 주소공간 (stack, data, code) 중 data, code를 공유하고 stack만 따로 쓴다.

PCB에서 program counter와 register만 별도로 유지하고, 다른 부분을 공유한다.



## 특징

장점

1. 하나의 서버 스레드가 blocking 상태인 동안에도 동일한 태스크 내의 다른 스레드가 실행되어 빠른 처리가 가능하다.
2. 다중 스레드가 협력하여 높은 처리율과 성능 향상을 얻을 수 있다.



# 프로세스 관리

## 생성

프로세스는 생성 시 자식이 부모의 공간을 복사한다. 자식은 그 공간에 새로운 프로그램을 올린다. 자원공유 형태에 따라 3가지로 나뉘는데, 부모와 자식이 모든 자원을 공유하는 모델, 일부 공유, 공유하지 않는 모델이 있다.

프로세스는 자원을 필요로하기 때문에 운영체제로부터 자원을 받고 부모와 이를 공유한다.



## 종료

프로세스는 자발적 종료와 강제 종료가 있다. 마지막 명령을 수행한 후, 운영체제에게 이를 알려주는 것(exit)이 자발적 종료다. 각종 프로세스의 자원들이 운영체제에게 반납된다. 부모 프로세스가 자식의 수행을 종료시키는 것(abort)이 강제 종료다. 



## 시스템 콜

1. fork()

2. exec()

3. wait()

4. exit()



**fork()**

프로세스는 fork에 의해 생성된다. 부모가 fork를 통해 자식 프로세스를 생성한다. 자식은 부모의 문맥을 그대로(fork()를 실행했다는 문맥까지) copy한다.

fork()의 결과값이 pid에 들어간다. 자식 프로세스는 fork()의 결과값이 0이다.

```c
int main(){
    int pid;
    pid = fork();
    if(pid==0) /* this is child*/
        // child logic
    else if(pid > 0) /* this is parent */
        // parent logic
}
```

똑같은 주소공간을 가진 2개의 프로세스가 생기는데, 실제로는 다른 프로그램을 실행할 수 있어야하는데 그래서 존재하는 것이 exec()이다.



**exec()**

exec() 시스템 콜에 의해 프로세스는 다른 프로그램을 실행할 수 있다. 프로세스를 새로 태어나게 만들어준다. 위의 `child logic` 부분에 아래 코드를 작성한다.

```c
execlp("/bin/date", "/bin/date", (char *) 0);
```

execlp 함수는 exec() 시스템 콜을 해준다. 부모가 자식을 만들어준다음 `/bin/date`라는 프로그램으로 덮어씌우는 과정이다. 



**wait()**

wait() 시스템 콜을 호출하면 자식이 종료될때 까지 기다린다.

1. 부모 프로세스를 sleep시킨다. (block)
2. child process가 종료되면 부모 프로세스를 깨운다. (ready)

 위의 `parent logic` 부분에 `wait()`을 작성한다.



**exit()**

호출 시 프로세스를 종료한다. 자발적 종료 시 사용된다. 



# IPC (Inter Process Communication)

프로세스는 다른 프로세스에게 영향을 받지 않고 독립적으로 실행된다. 프로세스 간의 통신을 해야하는 상황에 이를 돕는 것이 IPC 통신이다. 

프로세스는 커널이 제공하는 IPC 설비를 이용해 프로세스간 통신을 할 수 있게 된다.



1. 익명 PIPE : 통신할 프로세스를 명확히 알 수 있는 경우, 두 개의 프로세스를 연결하는 파이프를 이용한다. 하나의 프로세스는 데이터를 쓰기만, 하나는 읽기만 할 수 있다. 단순한 데이터 흐름에서 효율적이다.
2. Named PIPE : 전혀 모르는 상태의 프로세스들 사이 통신에 사용한다. 
3. Message Queue : 메세지 큐는 메모리 공간이다. 파이프처럼 데이터 흐름이 아니기때문에 여러 프로세스가 동시에 데이터에 번호로 접근할 수 있다.
4. 공유 메모리 : 데이터 자체를 공유하도록 지원하는 설비다. 프로세스간 메모리 영역을 공유해 사용할 수 있도록 허용해준다. IPC중에서 가장 빠르게 작동한다.
5. 메모리 맵 : 메모리를 공유하는 방식으로, 열린 파일을 메모리에 맵핑시켜 공유하는 방식이다. 
6. 소켓 : 클라이언트와 서버가 소켓을 통해 통신하는 구조로, 원격에서 프로세스간 데이터를 공유할 때 사용한다.

