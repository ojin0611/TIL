[toc]



# 운영체제

일반적으로  `하드웨어를 관리하고, 응용 프로그램과 하드웨어 사이에서 인터페이스 역할을 하며 시스템의 동작을 제어하는 시스템 소프트웨어`라고 정의한다.

1. CPU, 프로세서, 기억장치, 입출력 장치 등을 효율적으로 관리한다. (하드웨어 관리)
    - 사용자 간의 형평성 있는 자원 분배
    - 주어진 자원으로 최대한의 성능 내기
    - 사용자 및 운영체제 자신의 보호
    - 프로세스, 파일, 메세지 관리

2. 컴퓨터시스템을 편리하게 사용할 수 있는 환경 제공 (인터페이스 역할, 시스템의 동작 제어)
   - 여러 사용자, 프로그램들이 각각 독자적 컴퓨터에서 수행되는것 같은 환상을 제공
   - 하드웨어를 직접 다루는 복잡한 부분을 대행



# 컴퓨터 시스템 구조

![image-20210125202029011](images/image-20210125202029011.png)

## CPU

- CPU는 1개다. 누구한테 줄 지 CPU 스케줄링을 통해 결정한다.

- 매 클럭마다 메모리에서 instruction을 하나씩 읽고 실행한다.
- 매번 프로그램 카운터가 가리키고있는 곳의 명령을 수행한 뒤, 다음 명령을 수행하기 직전에 interrupt line이 세팅되었는지 체크한다.



## 메모리

- CPU가 잘 처리할 수 있게 준비하는 곳. 
- 한정된 메모리를 분배하는 것이 중요하다.



## 디스크

- 파일 관리. 파일을 어떻게 보관할지, 어떻게 파일을 빨리 읽을지 고민한다.



## Device Controller

- 키보드, 디스크 등 메모리가 아닌 곳에서 CPU에게 요청하기 위해 디바이스마다 device controller가 존재한다. 해당 device가 일을 다하면 CPU에게 interrupt를 날린다.
- device controller가 작업하는 공간, 즉 device마다 존재하는 별도의 작업공간이 local buffer다.



## Interrupt Line

- 각종 interrupt들이 기록돼있다. 
- CPU는 작업중인 instruction이 끝날때마다 interrupt line을 확인하고, interrupt가 있으면 OS에게 CPU 제어권을 넘긴다. 
- 이 때 mode bit 값이 변환된다. (0 : kernel mode, 1 : user mode)



## Timer

- 프로그램들에게 시간을 할당해준다. CPU가 독점되는것을 방지한다. 
- Timer도 Interrupt line에게 신호를 보낸다.



## DMA (Direct Memory Access)

- CPU에게 interrupt가 너무 많이 들어와 overhead가 크기때문에, 중간에서 interrupt를 한 번 실행해 메모리에 올려놓는다.
- local buffer에서 쌓인 작업량이 어느정도 채워지면 그 때 메모리로 보내고 interrupt를 날린다.
- 메인메모리에 DMA와 CPU 둘 다 접근할 수 있기 때문에, 메모리 컨트롤러는 CPU와 DMA 사이의 교통정리 역할을 한다.



# 캐시

캐시는 CPU 칩 안에 들어가는 작고 빠른 메모리다. 캐시에 자주 사용하는 데이터를 담아두고, 프로세서가 메인 메모리 대신 캐시에 접근하도록 하여 처리속도를 높이는 것이 캐시의 목적이다.



## 지역성

캐시 메모리를 효과적으로 사용하기 위해선 CPU가 어떤 데이터를 원할지 예측하는 능력이 중요하다. 이에 지역성(locality)이라는 용어가 등장한다. 지역성은 시간 지역성, 공간 지역성이 있다.



시간 지역성 : 최근에 접근한 데이터에 다시 접근하는 경향. (for문의 i)

공간 지역성 : 최근에 접근한 데이터의 주변 공간에 다시 접근하는 경향. 메모리에 순서대로 할당되기때문.



## 성능

캐시의 성능을 측정할 때는 hit latency와 miss latency를 이용한다.

CPU가 요청한 데이터가 캐시에 존재하면 캐시 Hit. 즉, hit latency = 캐싱된 데이터 가져올 때 소요되는 시간

CPU가 요청한 데이터가 캐시에 존재하지 않으면 캐시 Miss. 상위 캐시에서 데이터를 가져오거나 메모리에서 데이터를 가져올 때 소요되는 시간을 Miss latency.



# 동기 vs 비동기

## 동기 (Synchronous)

동시에 일어난다는 뜻으로, 요청과 그 결과가 동시에 일어난다는 약속이다. **동시에**라는 말은, 실행됐을 때 값이 반환되기 전까지 block 돼있다는 것을 의미한다. 바로 요청을 하면 시간이 얼마가 걸리던지 요청한 자리에서 결과가 주어져야 한다. 결과가 주어질 때까지 아무것도 못하고 대기해야한다.

내가 직접 빨래를 마치고, 이후에 설거지 끝낸 뒤 청소를 한다.



## 비동기 (Asynchronous)

동시에 일어나지 않는다는 의미다. 요청과 결과가 동시에 일어나지 않을 것이라는 약속이다. 요청한 그 자리에서 결과가 주어지지 않는다. 비동기의 경우 block되지않고 이벤트 큐에 넣거나 백그라운드 스레드에게 해당 task를 위임하고 다음 코드를 실행한다. 방식은 더 복잡하지만 자원을 효율적으로 사용할 수 있다.

빨래는 빨래 업체에, 설거지는 설거지 대행 업체에, 청소는 청소 대행 업체에 맡겼기때문에 어떤 것이 먼저 완료될지는 모른다. 다른 업체에 맡겼으니 그동안 나는 다른 작업을 할 수 있다. 



# 인터럽트

CPU에게 어떤 사실을 알려주거나 CPU의 서비스를 요청해야할 경우, CPU 내에 있는 interrupt line을 세팅하여 인터럽트를 발생시킨다. 

1. 하드웨어 인터럽트
   - 하드웨어 컨트롤러가 CPU의 서비스를 요청하기 위해 발생시키는 인터럽트
2. 소프트웨어 인터럽트 (Trap)
   - 예외 상황
   - 시스템 콜 : 사용자 프로세스가 OS의 서비스를 요청하기 위해 커널의 함수를 호출하는 것



## 인터럽트 처리 과정

CPU가 실행중인 A 프로그램이 인터럽트를 발생시키면 A는 현재 수행중인 명령의 위치를 저장한다. 이 때 A 프로세스의 정보를 PCB(Process Control Block)에 저장한다. 인터럽트 처리가 끝나면 프로그램 A의 PCB에 저장된 주소를 복원시킨다.



# 커널

프로그램이 실행되면 프로세스가 생성되고 메모리를 얻고, 프로그램이 종료되면 메모리에서 사라진다. 다른 프로세스들과 달리 **커널 영역**은 항상 메모리에 상주해있다. 

## 주소 공간

커널 주소 공간은 code, data, stack으로 구성돼있다.

code : 커널 코드 (시스템콜, 인터럽트 처리 코드 / 자원 관리 코드 등)

data : PCB 등.

stack : 프로세스들의 커널 스택



# 프로세스

## 주소 공간

프로그램이 CPU에 의해 실행되면 프로세스가 생성되고, 메모리에 프로세스 주소 공간이 할당된다.

code : 소스 코드 자체를 구성하는 메모리 영역

data : 전역변수, 정적변수, 배열 (초기화된 데이터)

heap : 동적 할당 시 사용 (`new()`, `malloc()` 등)

stack : 지역변수, 매개변수, 리턴 값 (임시 메모리 영역)



## Context

프로세스의 문맥(context)은 프로세스에 대한 정보로, 하드웨어 문맥(Program Counter, register), 프로세스의 주소공간(code,data,stack), 프로세스 관련 커널 자료 구조(PCB, kernel stack)를 포함하고 있다.

PCB는 프로세스를 관리할 필요가 있는 정보를 포함하는 운영체제 커널의 자료구조다. 운영체제가 프로세스를 관리하기 위해 유지하는 프로세스의 정보다. 프로세스 생성 시 PCB가 생성되고, 프로세스가 완료되면 제거된다.



## 상태

프로세스는 상태가 변경되며 수행된다.

![image-20210602140336494](images/image-20210602140336494.png) 

New : 생성중

Ready : CPU를 기다리는 상태. 메모리에 프로세스를 올려놓고 CPU가 instruction을 바로 실행할 수 있게 대기중.

Running : CPU를 잡고 instruction을 수행중인 상태.

> Running에서 빠져나오는 방법은 3가지다. I/O, Timer, Exit

Blocked(=wait, sleep) : I/O같은 오래 걸리는 작업을 하고 있어 CPU를 얻어도 소용없는 상태다. 프로세스가 요청한 이벤트가 즉시 만족되지않아 이를 기다리는 상태다.

Suspended(=stopped) : 외부적인 이유로 프로세스 수행이 정지된 상태. 디스크에 swap out된다. blocked는 event를 만족하면 ready가 되지만 suspended는 외부에서 resume해줘야 active된다. 

Terminated : 수행이 끝난 상태

![image-20210602183007135](images/image-20210602183007135.png) 



## Context Switching

프로세스의 상태 정보를 저장하고 복원하는 일련의 과정.

즉, 동작 중인 프로세스가 대기하면서 해당 프로세스의 상태를 PCB에 보관하고, 대기하고 있던 다음 순번의 프로세스가 동작하면서 이전에 PCB에 보관했던 프로세스 상태를 복구하는 과정을 말한다.

> 프로세스는 각 독립된 메모리 영역을 할당받아 사용되므로, 캐시 메모리 초기화와 같은 무거운 작업이 진행되었을 때 오버헤드가 발생할 문제가 존재한다.



"프로세스 A -> 시스템콜 -> 프로세스 A" 의 경우, PCB에 프로세스 문맥을 저장하지만 context switching은 발생하지 않는다. "프로세스 A -> kernel mode -> 프로세스 B"의 경우는 문맥 교환이 발생해 오버헤드가 커진다. (cache memory flush 등)



# 프로세스 스케줄링

프로세스는 프로세스 큐들을 왔다갔다하면서 (놀이동산에서 놀이기구 줄 서듯이) 줄을 선다. 이 큐들은 커널의 data 영역에 존재하고, 프로세스 상태에 따라 CPU를 주거나 주지 않는다. 큐의 종류는 Ready Queue, Device Queues, Resource Queue 등이 있다. 

위의 큐에 존재하는 프로세스들의 작업 순서를 정해주는 일(스케줄링)이 필요한데 이 작업을 스케줄러가 해준다.

## 스케줄러

**Short-term scheduler** : CPU scheduler. 어떤 프로세스를 다음번에 running시킬지 결정한다. 

**Long-term scheduler** : Job Scheduler. New 상태의 프로세스를 ready queue로 보낼지 결정한다. (admit) 프로세스에 메모리를 주는 문제를 해결하고, 메모리에 프로그램을 몇 개 올릴 지 제어하는 역할을 한다. 근데 요즘(보통, time-sharing system)은 무조건 ready 상태로 보낸다. 

**Medium-term scheduler** : swapper라고도 불리며, 여유 공간 마련을 위해 프로세스를 통째로 메모리에서 디스크로 쫓아낸다. 



# 쓰레드

동일한 일을 하는 프로세스가 여러 개 있으면 메모리 낭비가 발생한다. 이 때 하나의 메모리를 띄우고, 프로세스마다 다른 부분의 코드를 실행하면 효율적인데 이 개념을 도입한게 thread다. 

프로세스의 주소공간 (stack, data, code) 중 data, code를 공유하고 stack만 따로 쓴다.

PCB에서 program counter와 register만 별도로 유지하고, 다른 부분을 공유한다.



## 특징

장점

1. 하나의 서버 스레드가 blocking 상태인 동안에도 동일한 태스크 내의 다른 스레드가 실행되어 빠른 처리가 가능하다.
2. 다중 스레드가 협력하여 높은 처리율과 성능 향상을 얻을 수 있다.



# 프로세스 관리

## 생성

프로세스는 생성 시 자식이 부모의 공간을 복사한다. 자식은 그 공간에 새로운 프로그램을 올린다. 자원공유 형태에 따라 3가지로 나뉘는데, 부모와 자식이 모든 자원을 공유하는 모델, 일부 공유, 공유하지 않는 모델이 있다.

프로세스는 자원을 필요로하기 때문에 운영체제로부터 자원을 받고 부모와 이를 공유한다.



## 종료

프로세스는 자발적 종료와 강제 종료가 있다. 마지막 명령을 수행한 후, 운영체제에게 이를 알려주는 것(exit)이 자발적 종료다. 각종 프로세스의 자원들이 운영체제에게 반납된다. 부모 프로세스가 자식의 수행을 종료시키는 것(abort)이 강제 종료다. 



## 시스템 콜

1. fork()

2. exec()

3. wait()

4. exit()



**fork()**

프로세스는 fork에 의해 생성된다. 부모가 fork를 통해 자식 프로세스를 생성한다. 자식은 부모의 문맥을 그대로(fork()를 실행했다는 문맥까지) copy한다.

fork()의 결과값이 pid에 들어간다. 자식 프로세스는 fork()의 결과값이 0이다.

```c
int main(){
    int pid;
    pid = fork();
    if(pid==0) /* this is child*/
        // child logic
    else if(pid > 0) /* this is parent */
        // parent logic
}
```

똑같은 주소공간을 가진 2개의 프로세스가 생기는데, 실제로는 다른 프로그램을 실행할 수 있어야하는데 그래서 존재하는 것이 exec()이다.



**exec()**

exec() 시스템 콜에 의해 프로세스는 다른 프로그램을 실행할 수 있다. 프로세스를 새로 태어나게 만들어준다. 위의 `child logic` 부분에 아래 코드를 작성한다.

```c
execlp("/bin/date", "/bin/date", (char *) 0);
```

execlp 함수는 exec() 시스템 콜을 해준다. 부모가 자식을 만들어준다음 `/bin/date`라는 프로그램으로 덮어씌우는 과정이다. 



**wait()**

wait() 시스템 콜을 호출하면 자식이 종료될때 까지 기다린다.

1. 부모 프로세스를 sleep시킨다. (block)
2. child process가 종료되면 부모 프로세스를 깨운다. (ready)

 위의 `parent logic` 부분에 `wait()`을 작성한다.



**exit()**

호출 시 프로세스를 종료한다. 자발적 종료 시 사용된다. 



# IPC (Inter Process Communication)

프로세스는 다른 프로세스에게 영향을 받지 않고 독립적으로 실행된다. 프로세스 간의 통신을 해야하는 상황에 이를 돕는 것이 IPC 통신이다. 

프로세스는 커널이 제공하는 IPC 설비를 이용해 프로세스간 통신을 할 수 있게 된다.



1. 익명 PIPE : 통신할 프로세스를 명확히 알 수 있는 경우, 두 개의 프로세스를 연결하는 파이프를 이용한다. 하나의 프로세스는 데이터를 쓰기만, 하나는 읽기만 할 수 있다. 단순한 데이터 흐름에서 효율적이다.
2. Named PIPE : 전혀 모르는 상태의 프로세스들 사이 통신에 사용한다. 
3. Message Queue : 메세지 큐는 메모리 공간이다. 파이프처럼 데이터 흐름이 아니기때문에 여러 프로세스가 동시에 데이터에 번호로 접근할 수 있다.
4. 공유 메모리 : 데이터 자체를 공유하도록 지원하는 설비다. 프로세스간 메모리 영역을 공유해 사용할 수 있도록 허용해준다. IPC중에서 가장 빠르게 작동한다.
5. 메모리 맵 : 메모리를 공유하는 방식으로, 열린 파일을 메모리에 맵핑시켜 공유하는 방식이다. 
6. 소켓 : 클라이언트와 서버가 소켓을 통해 통신하는 구조로, 원격에서 프로세스간 데이터를 공유할 때 사용한다.





---

참고자료

- [반효경 교수님의 운영체제 강의 정리](https://www.notion.so/yyj/OS-103231d659124eabaad0346c0a0613e3)

- [WooVictory Github](https://github.com/WooVictory/Ready-For-Tech-Interview)

- [gyoogle Github](https://github.com/gyoogle/tech-interview-for-developer)

