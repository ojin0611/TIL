# 네트워크

## 책 내용 정리 

[모두의 네트워크 책 정리](./모두의네트워크.md)

![image-20210119215358585](images/image-20210119215358585.png)



[TOC]

# OSI, TCP

## TCP/IP Layer

현재 수많은 프로그램들이 인터넷으로 통신하는데 있어 가장 기반이 되는 프로토콜로, 네트워크 액세스 계층, 인터넷 계층, 전송 계층, 응용 계층으로 구성돼있다.

네트워크 액세스 계층 : 실제 데이터 송수신 역할

인터넷 계층 : 데이터 전송을 위한 주소 지정, 경로 지정 제공

전송 계층 : 호스트 간 신뢰성 있는 통신 제공 (ex. TCP, UDP)

응용 계층 : App간 데이터 송수신 제공 (ex. HTTP, DNS)



## IP

IP는 네트워크 계층의 프로토콜로, 패킷의 분해, 조립, 주소 지정, 경로 선택 기능을 제공한다.

IP 주소는 인터넷에 연결된 모든 컴퓨터 자원을 구분하기 위한 고유 주소다.



# TCP, UDP

## TCP (Transmission Control Protocol)

TCP는 흐름제어, 혼잡제어, 오류제어를 통해 신뢰성을 보장한다. 이 때문에 UDP보다 전송 속도가 느리다.

### 흐름 제어

송신측의 속도가 수신측의 속도보다 빠르면 데이터 손실이 발생하기 때문에 송신측과 수신측의 속도차이를 맞춰주는 기법이다.

1. Stop and Wait : 전송한 패킷에 대한 확인 응답을 받아야 그 다음 패킷을 전송할 수 있다.
2. Sliding Window : 수신측에서 설정한 윈도우 크기만큼 송신측에서 확인 응답 없이 세그먼트를 전송할 수 있게 되어 데이터 흐름을 동적으로 조절할 수 있다.

### 오류 제어

ARQ(Automatic Repeat Request) 기법을 사용해 프레임의 손상 또는 손실 유무에 따라 재전송을 통해 오류를 복구한다. 흐름 제어 기법과 관련돼있다.

1. Stop and Wait ARQ : 각 프레임의 에러 유무에 따라 ACK or NAK를 보낸다.
2. Go-Back-n ARQ (슬라이딩 윈도우) : 확인된 마지막 프레임 이후 모든 프레임을 재전송한다.

### 혼잡 제어

네트워크의 혼잡을 피하기 위해 송신측에서 보내는 데이터의 전송 속도를 제어하는 것이다.

AIMD, Slow Start 등이 있다.



## 3 handshaking, 4 handshaking

3-handshaking : 연결 확립 요청. SYN / SYN+ACK / ACK

- 첫 요청 시 Sequence Number를 랜덤하게 보낸다. 기존 패킷과 혼동될 수도 있고, 보안도 강화되기 때문이다. 

4-handshaking : 연결 종료 요청. FIN / ACK / FIN / ACK. 

- 이 때 혹시나 routing 지연으로 인한 데이터 전송이 발생할 수 있기 때문에 잉여 패킷을 기다리는 과정이 존재한다.
- 클라이언트의 데이터 요청이 끝나 FIN을 보내도 서버는 아직 보낼 데이터가 남아있을 수도 있기 때문에 우선 클라이언트의 FIN에 대해서만 ACK하고, 서버의 데이터 전송이 끝나면 그제서야 서버도 FIN 세그먼트를 보낸다. 



각 단계에서 Timeout 발생하면 다시 세그먼트를 보내고 수신을 대기한다.



## UDP (User Datagram Protocol)

데이터를 데이터 그램 단위로 처리하는 프로토콜이다. 데이터 그램은 독립적인 관계를 지니는 패킷을 말한다.

하나의 메세지에서 분할된 각각의 패킷은 서로 다른 경로로 전송될 수 있고 도착한 패킷의 순서가 다를 수 있다. 

Real Time Protocol, Multicast, DNS 등에서 사용된다. (RTP : 여보세요 -> 여보요세?, Multicast : 1대N 데이터 전송인데, 오류 시 전체 다 보낼 순 없다.)

DNS는 문의,응답 모두 하나의 패킷 UDP에서 할 수 있도록 설계돼있다. 



## Reliable UDP (RUDP)

[참고 블로그](http://blog2928.kc39.net/13263)

UDP에서 신뢰도를 보장하는 방법으로 RUDP를 사용한다. 기본적으로 UDP의 가장 큰 단점인 unreliable 한 특성을 보완하는 것이 핵심이다. 실시간 게임에서 사용된다. 

UDP와 비교했을 때 TCP의 Reliable한 특성을 세 가지로 요약할 수 있다.

- 데이터의 변형이 없다.
- 데이터의 손실이 없다.
- 데이터가 순차적으로 도착한다.



### 패킷구성

전송하는 게임 패킷에 RDUP 관련된 헤더를 추가해서 네트워크 패킷을 구성한다. 일반적으로 필요한 구성요소는 4가지 정도가 된다.

- 전송타입
- 패킷의 고유넘버
- 에러 검출코드
- 게임 패킷 데이터



### 데이터 전송 타입

RUDP에서 UDP의 특성을 보완하는 것은 **전송을 보장**하는 것과 **순서를 보정**하는 것 두 가지가 된다. 이런 특성을 토대로 3가지 타입의 패킷을 나눌 수 있다.

1. UDP고유의 전송을 보장하지 않는 타입 (도착하지 않더라도 문제가 없다.)
2. 전송을 보장하지만 순서를 상관없는 타입 (도착만 하면 된다.)
3. 전송을 보장하며, 보낸 순서대로 받는 타입 (TCP 의 특성과 비슷)

이를 활용해 게임에서 다양한 상황을 구현한다.



# HTTP, HTTPS

## HTTP

HTTP는 평문 통신이기때문에 도청이 가능하고, 통신 상대를 확인하지 않아 위장이 가능하다. 

HTTP는 연결에 필요한 리소스를 아껴 더 많은 클라이언트와 연결하기 위해 비연결성 방식을 채택한다.



## 버전 차이

**HTTP1.0**

요청을 보낼 때마다 연결 수립/끊기를 반복한다.



**HTTP1.1**

데이터 교환을 마칠 때까지 연결을 유지한다.



**HTTP2**

HTTP/2의 등장은 "streams"라는 개념을 도입하였다. 이것은 서로 다른 HTTP 연결들을 **하나의 TCP 스트림**으로 다중화하여 추상화 할 수 있는 개념으로, 브라우저에서 보다 효율적으로 TCP연결을 재사용 할 수 있도록 지원하는 개념이다.



**HTTP3**

기존 버전(TCP 이용)들과 달리 UDP 프로토콜을 이용한다.



## HTTPS

HTTPS는 HTTP 통신을 하되 소켓 부분을 SSL라는 프로토콜로 대체한 것이다. HTTP는 SSL과 통신하고 SSL이 TCP와 통신하게 된다. HTTPS의 SSL에서는 대칭키 암호화 방식과 공개키 암호화 방식을 모두 사용한다. 



## GET, POST

GET은 데이터를 헤더에 담아서 전달한다. GET은 서버의 상태를 변경하지 않는다.

POST는 생성할 때 사용. 데이터를 body에 담아 전달한다.






# 대칭키와 공개키

## 대칭키

대칭키 암호화 방식 : 암복호화 키가 동일한 암호화 방식으로, 수행시간이 짧지만 안전한 키교환 방식이 요구되고, 사람이 증가할수록 관리해야할 키가 방대하게 많아진다.



## 공개키

공개키 암호화 방식 : 대칭키의 키교환 문제를 해결하기 위해 등장한 것으로, 키가 공개돼있기때문에 키를 교환할 필요가 없어진다. 공개키는 모든사람이 접근 가능한 키, 개인키는 각 사용자만이 갖고 있는 키다.

### 공개키로 암호화

공개키로 암호화하고, 개인키로 복호화하기때문에 개인키를 갖고있는 사람만 암호화된 데이터를 볼 수 있다.

공개키는 공개돼있기때문에 키교환이나 분배를 할 필요가 없어진다. 중간 공격자가 공개키를 얻어도 개인키로만 복호화가 가능하기 때문에 기밀성을 제공하고, 개인키를 갖고있는 수신자만이 암호화된 데이터를 복호화할 수 있다.



### 비밀키로 암호화

인증에 공개키가 사용될 수 있다. B는 A가 보낸 데이터인지 확인하고싶다. A는 비밀키로 암호화된 데이터와 공개키를 B에게 전송한다. 이 때 공개키는 암호로써의 역할을 하진 못하지만 해당 데이터는 비밀키를 사용한 사람만이 암호화할 수 있기때문에 이 데이터가 A가 보낸 데이터임을 보장한다.



### 대칭키 공유하기

위와 같이 공개키 암호화를 이용해 데이터를 주고받을 때 시간이 오래걸린다. 공개키와 개인키는 길이가 굉장히 길기때문에 암복호화 시간이 오래 걸리기 때문이다. 효율성에서 떨어지기때문에 보통 대칭키를 공유하고 대칭키를 이용해 메세지를 주고받는 것이 일반적이다.

Idea : 공개키로 암호화하고, 개인키로 복호화한다. 보내는 데이터는 탈취돼도 보안에 문제가 발생하지 않는다.

1. A와 B가 각자 공개키와 개인키를 갖고 있다.
2. A와 B가 서로의 공개키를 오픈된 공간에 올려놓는다. 
3. A는 B의 공개키를 획득하고, B는 A의 공개키를 획득한다.
4. A가 대칭키 1을 생성한다.
5. A는 B의 공개키로 대칭키 1을 암호화한다.  암호화된 대칭키 1을 B에게 보낸다.
6. B는 A가 전송한 암호화된 대칭키 1을 자신의 개인키로 복호화한다. B는 A가 보낸 대칭키 1의 원본을 획득한다.
7. B는 대칭키 2를 생성한다.
8. B는 A의 공개키로 대칭키 2를 암호화한다. 암호화된 대칭키 2를 A에게 보낸다.
9. A는 B가 전송한 암호화된 대칭키 2를 자신의 개인키로 복호화한다. A는 B가 보낸 대칭키 2의 원본을 획득한다.



# DNS

## DNS 동작 과정

1. 사용자 컴퓨터 OS의 host에 `www.naver.com` 도메인의 IP 주소 저장돼있는지 확인한다.
2. 가장 가까운 local DNS 서버를 확인한다.
3. ROOT 서버에 확인. 이 때 `.com`의 주소를 알고 있는 Top Level의 서버 주소를 알려준다.

4. Top Level 서버는 `naver.com`의 주소를 알고 있는 Second Level의 서버 주소를 알려준다.
5. Second Level 서버는 `www.naver.com`의 주소를 알고있는 Sub 서버의 주소를 알려준다.

6. Sub 서버는 사용자에게 `www.naver.com`의 IP 주소를 알려준다.



## DNS 방식

round robin : 여러 개 IP의 순서를 정해서 제공하는 방식이다.  CPU 스케줄링의 라운드 로빈 방식





# 로드 밸런서 (Load Balancer)

## 로드 밸런싱

서버를 여러 대 사용할 때, 트래픽이 몰리면 여러 서버에 균등하게 트래픽을 분산처리하는 기술이다. 종류가 여러가지 있다. (L2, L3, L4, L7 로드밸런싱 등) L2는 Mac 주소를 바탕으로, L3은 IP 주소를 바탕으로, L4는 4층, Transport Layer(IP, Port)에서, L7은 7층(애플리케이션 계층)에서 사용된다.

L4는 **패킷 레벨**에서만 트래픽을 분산하기 때문에 속도가 빠르고 효율성이 높으며 L7보다 저렴하다. L7은 HTTP Header, Cookie 등과 같이 사용자가 요청한 정보들을 바탕으로 트래픽을 분산하기때문에 섬세한 라우팅이 가능하고, 비정상적인 트래픽을 판별할 수 있다. L4 로드밸런싱보다 가격이 비싸다.



> Scale-up : 하드웨어의 성능 올리기, Scale-out : 여러 대의 서버가 나눠서 일하도록 만드는 것.



## 서버 선택 방식

Round-robin : CPU 스케줄링의 라운드 로빈 방식 활용

Least Connections : 연결 갯수가 가장 적은 서버 선택. 세션이 길어지는 경우 권장한다.

Source : 사용자 IP를 해싱하여 분배. 특정 사용자를 항상 같은 서버로 연결시킬 수 있다.



# Web

## CORS

서로 다른 origin끼리 자원을 공유할 수 있는 방식이다. HTTP 헤더를 사용해 한 origin에서 실행중인 웹앱이 다른 origin의 자원에 접근할 수 있는 **권한을 부여**할 수 있는 방식이다.

> 서로 다른 origin : Protocol, Host, Port 중 하나라도 다른 것



## Socket

> 소켓(Socket)은 프로세스가 드넓은 네트워크 세계로 데이터를 내보내거나 혹은 그 세계로부터 데이터를 받기 위한 실제적인 창구 역할을 한다. 그러므로 프로세스가 데이터를 보내거나 받기 위해서는 반드시 소켓을 열어서 소켓에 데이터를 써보내거나 소켓으로부터 데이터를 읽어들여야 한다.

소켓은 프로세스가 네트워크를 통해 데이터를 주고받기 위해 필요한 통로다.

소켓은(Socket)은 프로토콜, IP 주소, 포트 넘버로 정의된다. **소켓을 열기 위해선 호스트에 할당된 IP 주소, 포트 넘버, 프로토콜(Protocol) 등이 필요하며, 이 세 가지가 소켓을 정의한다.** 

프로세스가 네트워크 통신을 하기 위해서는 포트를 할당받아야 하는데, 서버의 경우에는 보통 하나만 할당받는다. **왜냐하면 같은 프로세스가 같은 포트를 가지고도 여러 개의 소켓을 열 수 있기 때문이다.** 

**하나의 프로세스는 같은 프로토콜, 같은 IP 주소, 같은 포트 넘버를 가지는 수십 혹은 수만 개의 소켓을 가질 수 있다.** 이런 이유 때문에 하나의 프로세스는 하나의 포트만으로도 다른 여러 호스트에 있는 프로세스의 요청을 처리할 수 있고, 게임 서버의 동시 접속자 수가 수십수백만이 될 수 있는 것이다.



**소켓을 정의하는 것과 소켓을 식별하는 것을 구분하자. IP 주소, 포트 넘버, 프로토콜로 소켓을 정의할 수 있지만, 이것이 소켓을 유일하게 식별하진 않는다.** 이름이 홍길동이라고 해도 여러 홍길동이 있는 것처럼, 같은 IP 주소, 포트 넘버, 프로토콜을 가지는 소켓이라고 해도, 서로 다른 소켓이 존재하는 것이다. 



출처 [소켓(Socket) 포트(Port) 뜻과 차이](http://blog.naver.com/myca11/221389847130)



## 브라우저에 www.naver.com 입력 시

1. 브라우저에 도메인을 입력한다.
2. DNS 서버가 도메인의 IP를 클라이언트에게 알려준다.
3. 클라이언트는 해당 IP로 접속한다. 
   1. 이 때 ARP 프로토콜을 이용해 목적지의 MAC 주소로 접근한다.
   2. TCP 소켓 스트림을 요청한다. (3-way handshake)
4. 해당 IP의 서버가 HTTP 프로토콜을 이용해 클라이언트에게 `index.html`을 보낸다.
5. 브라우저는 `index.html` 의 텍스트를 파싱한다.
   1. 한 줄씩 읽으면서 DOM 트리를 형성한다.
   2. 중간에 link 태그를 만나면 css를 파싱한다.
   3. 완성된 DOM 트리와 CSSOM 트리를 합쳐 Renter Tree를 만들고 그린다.
   4. HTML 파서가 중간에 script 태그를 만나면 javascript 코드를 실행하기 위해 파싱을 중단한다.
   5. javascript 엔진이 javascript 코드 또는 파일을 로드해 파싱하고 실행한다.







# Cookie, Session

## 사용 이유

세션과 쿠키는 http의 비연결성을 해결하기 위해 사용자 정보를 저장한다. 세션은 서버에 저장되어 안전하지만 세션만을 사용하면 서버에 부하가 발생한다. 쿠키는 클라이언트 저장소에 저장돼 서버에 부하를 주지 않지만 세션보다 보안성이 낮다.



## 쿠키 동작 방식

1. 웹 브라우저가 서버에 요청
2. 상태를 유지하고 싶은 값을 쿠키로 생성
3. 서버가 응답할 때 HTTP 헤더에 쿠키를 포함해 전송
4. 웹브라우저는 전달받은 쿠키를 관리하다가, 다음 요청 때 쿠키를 HTTP 헤더에 넣어서 전송한다.
5. 서버에서는 쿠키 정보를 읽어 이전 상태 정보를 확인한 후 응답.



## 세션 동작 방식

1. 웹 브라우저가 서버에 요청
2. 서버가 웹브라우저에 유일한 ID를 부여
3. 서버가 응답할때 HTTP 헤더에 Session ID를 포함해 전송. 쿠키에 Session ID를 저장 (JSESSIONID)
4. 웹 브라우저는 다음 요청때 부여된 Session ID가 담겨있는 쿠키를 HTTP 헤더에 넣어서 전송.
5. 서버는 세션ID를 확인하고, 해당 세션에 관련된 정보를 확인 후 응답한다.



## 세션 인증방식

세션 인증방식 사용 시 서버의 메모리에 세션 데이터가 저장되므로, 다수의 서버를 사용할 때 문제가 발생한다. 모든 서버가 접근할 수 있는 별도의 중앙세션 관리 시스템이 필요하고, 이 관리 시스템에 장애가 발생하면 전체 시스템에 문제가 발생한다.



## 토큰 인증 방식

로그인 성공 시 서버로부터 접근 토큰을 부여받는다. 이후 클라이언트가 모든 API 요청을 할 때 접근 토큰(access token)을 포함시킨다. 서버는 접근 토큰을 해독해 확인하고 검증되면 해당 API 기능을 수행한다. 기한이 만료되면 접근 토큰을 지우고 재로그인하게 한다.

JWT는 JSON Web Token의 약자로, 전자서명된 URL-safe한 json이다. URL로 이용할 수 있는 문자로만 구성됐다는 의미다.



